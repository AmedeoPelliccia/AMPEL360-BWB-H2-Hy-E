# Copyright 2025 AMPEL360 Project Contributors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#!/usr/bin/env python3
"""
CGen Lane 1 ‚Äì Directory index generator for AMPEL360 / OPT-IN Framework.

- Scans the repository tree (or a given root)
- Creates/updates 00_INDEX.md in selected documentation folders
- Skips tooling/infra directories (git, venv, node_modules, tools, etc.)
- Default mode is DRY-RUN; use --write to apply changes.
"""

import argparse
from pathlib import Path
from datetime import datetime, timezone
from typing import Iterable, List, Tuple

# --- CONFIGURATION ---

# Folders to ignore during indexing
IGNORE_DIRS = {
    ".git", ".github", "__pycache__", "venv", "node_modules",
    ".idea", ".vscode", "tools", ".mypy_cache", ".pytest_cache",
    "mcp-pr-memory", "dist", "build", "egg-info"
}

# Canonical 14-folder lifecycle for OPT-IN / ATA chapters
OPTIN_LIFECYCLE_FOLDERS = {
    "01_OVERVIEW",
    "02_SAFETY",
    "03_REQUIREMENTS",
    "04_DESIGN",
    "05_INTERFACES",
    "06_ENGINEERING",
    "07_V_AND_V",
    "08_PROTOTYPING",
    "09_PRODUCTION_PLANNING",
    "10_CERTIFICATION",
    "11_EIS_VERSIONS_TAGS",
    "12_SERVICES",
    "13_SUBSYSTEMS_COMPONENTS",
    "14_OPS_STD_SUSTAIN",
}

# Optional legacy SE 14-folder pattern (if you still use it somewhere)
LEGACY_SE_STRUCTURE = {
    "01-Requirements",
    "02-Architecture",
    "03-Design",
    "04-Implementation",
    "05-Integration",
    "06-Verification",
    "07-Validation",
    "08-Maintenance",
    "09-Safety",
    "10-Security",
    "11-HumanFactors",
    "12-Operations",
    "13-Certification",
    "14-Management",
}

STANDARD_STRUCTURE = OPTIN_LIFECYCLE_FOLDERS | LEGACY_SE_STRUCTURE

HEADER_TEMPLATE = """# {title}

> **Generated By:** CGen (Lane 1 ‚Äì Directory Indexer)
> **Last Update:** {date}
> **Note:** This index is auto-generated. Do not edit manually; update contents by changing files in this directory and re-running CGen.

## üìÇ Directory Contents
"""


def get_file_info(file_path: Path) -> Tuple[float, str]:
    """Extract simple metadata for the file (size in KB, last modified date)."""
    stats = file_path.stat()
    size_kb = round(stats.st_size / 1024, 2)
    mod_time = datetime.fromtimestamp(stats.st_mtime).strftime("%Y-%m-%d")
    return size_kb, mod_time


def generate_markdown_table(directory: Path) -> str:
    """Scan a directory and return a Markdown table of its contents."""
    lines: List[str] = [
        "| File Name | Size (KB) | Last Modified |",
        "|:---|:---:|:---:|",
    ]

    has_entries = False

    # Sort: directories first, then files; both alphabetically
    try:
        entries = sorted(
            list(directory.iterdir()),
            key=lambda x: (not x.is_dir(), x.name.lower()),
        )
    except PermissionError:
        return "\n*This directory cannot be listed due to permission restrictions.*\n"

    for entry in entries:
        name = entry.name

        # Skip ignored directories and hidden/system files
        if name in IGNORE_DIRS or name.startswith("."):
            continue

        # Do not index the index itself or the README
        if name in {"00_INDEX.md", "README.md"}:
            continue

        if entry.is_dir():
            lines.append(f"| üìÅ **[{name}/]({name}/)** | - | - |")
            has_entries = True
        elif entry.is_file():
            size, mod = get_file_info(entry)
            lines.append(f"| üìÑ [{name}]({name}) | {size} | {mod} |")
            has_entries = True

    if not has_entries:
        return "\n*This directory is currently empty.*\n"

    return "\n".join(lines)


def should_index_directory(dir_path: Path, root_path: Path) -> bool:
    """
    Decide whether this directory should get a 00_INDEX.md.

    Heuristics:
    - Skip any directory that includes an ignored segment.
    - Always index if 00_INDEX.md already exists (maintenance).
    - Index canonical lifecycle folders (01_OVERVIEW, 02_SAFETY, etc.).
    - Index ATA-like folders starting with two digits + '-' or '_' (e.g. 02-30-01_Something).
    """
    # Ignore based on path segments
    if any(part in IGNORE_DIRS for part in dir_path.parts):
        return False

    # Always maintain existing indexes
    if (dir_path / "00_INDEX.md").exists():
        return True

    name = dir_path.name

    # Canonical 14-folder lifecycle & legacy SE structure
    if name in STANDARD_STRUCTURE:
        return True

    # Simple ATA-style heuristic: "NN-..." or "NN_..."
    if len(name) >= 3 and name[:2].isdigit() and name[2] in {"-", "_"}:
        return True

    return False


def process_directory(root_path: Path, dry_run: bool = True) -> None:
    """Recursively traverse directories under root_path and update 00_INDEX.md."""
    # Cache to avoid re-checking paths
    processed_paths = set()
    
    for dir_path in root_path.rglob("*"):
        if not dir_path.is_dir():
            continue
        
        # Skip if already processed or if it's an ignored directory
        if dir_path in processed_paths:
            continue
        
        # Quick skip for ignored dirs
        if any(part in IGNORE_DIRS for part in dir_path.parts):
            continue

        if not should_index_directory(dir_path, root_path):
            continue
        
        processed_paths.add(dir_path)

        mode = "DRY-RUN" if dry_run else "WRITE"
        print(f"[{mode}] Processing: {dir_path}")

        table_content = generate_markdown_table(dir_path)

        rel = dir_path.relative_to(root_path)
        title = f"Index: {rel.as_posix()}" if rel != Path(".") else "Index: ."

        new_content = HEADER_TEMPLATE.format(
            title=title,
            date=datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M UTC"),
        ) + "\n" + table_content

        target_file = dir_path / "00_INDEX.md"

        if dry_run:
            print(f"   -> Would write {len(new_content)} bytes to {target_file}")
        else:
            target_file.write_text(new_content, encoding="utf-8")
            print(f"   -> Updated {target_file}")


def main() -> None:
    parser = argparse.ArgumentParser(
        description="CGen: Auto-generate 00_INDEX.md directory indexes."
    )
    parser.add_argument(
        "--root",
        type=str,
        default=".",
        help="Root directory to scan (default: current directory).",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Explicitly enable dry-run mode (already the default behavior).",
    )
    parser.add_argument(
        "--write",
        action="store_true",
        help="Actually write changes to disk.",
    )

    args = parser.parse_args()

    # Safety: default to dry-run unless --write is explicitly passed
    dry_run = not args.write or args.dry_run

    if dry_run:
        print("‚ö†Ô∏è  RUNNING IN DRY-RUN MODE. No files will be changed.")

    root_dir = Path(args.root).resolve()
    print(f"Scanning root: {root_dir}")
    process_directory(root_dir, dry_run=dry_run)


if __name__ == "__main__":
    main()
